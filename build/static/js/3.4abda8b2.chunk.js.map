{"version":3,"sources":["../node_modules/react-table/dist/index.es.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_objectWithoutProperties","excluded","sourceKeys","indexOf","_objectWithoutPropertiesLoose","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_slicedToArray","arr","Array","isArray","_arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","err","_iterableToArrayLimit","TypeError","_nonIterableRest","_toConsumableArray","arr2","_arrayWithoutHoles","iter","toString","from","_iterableToArray","_nonIterableSpread","defaultColumn","Cell","_ref","_ref$cell$value","cell","String","show","width","minWidth","maxWidth","Number","MAX_SAFE_INTEGER","window","useLayoutEffect","useEffect","decorateColumn","column","userDefaultColumn","parent","depth","index","_column","id","accessor","Header","accessorPath","split","row","getBy","columns","console","error","Error","createElement","Fragment","decorateColumnTree","map","columnIndex","makeHeaderGroups","flatColumns","headerGroups","buildGroup","headerGroup","headers","parentColumns","hasParents","some","col","isFirst","latestParentColumn","concat","reverse","similarParentColumns","d","originalID","join","_similarParentColumns","placeholderColumn","placeholderOf","includes","totalHeaderCount","reduce","sum","header","determineHeaderVisibility","instance","totalVisibleHeaderCount","subHeader","handleColumn","parentVisible","isVisible","subColumn","path","def","val","pathObj","flattenDeep","newArr","replace","makePathArray","cursor","pathPart","e","defaultOrderByFn","funcs","dirs","sort","rowA","rowB","sortFn","desc","sortInt","getFirstDefined","flexRender","Comp","props","component","proto","getPrototypeOf","isReactComponent","isClassComponent","isFunctionComponent","mergeProps","_len","groups","_key","_ref2","_ref2$style","style","className","rest","Boolean","applyHooks","hooks","initial","_len2","args","_key2","prev","nextValue","applyPropHooks","_len3","_key3","isFunction","a","flattenBy","childKey","recurse","ensurePluginOrder","plugins","befores","pluginName","afters","pluginIndex","findIndex","plugin","before","beforeIndex","after","afterIndex","propTypes","data","array","isRequired","arrayOf","getSubRows","func","getRowID","debug","bool","renderErr","defaultState","defaultInitialState","defaultColumnInstance","defaultReducer","old","newState","defaultGetSubRows","subRows","defaultGetRowID","useTable","checkPropTypes","userColumns","_props$initialState","initialState","userState","state","_props$defaultColumn","defaultColumn$$1","_props$getSubRows","_props$getRowID","_props$reducer","reducer","_React$useState","useState","_React$useState2","originalState","originalSetState","useMemo","setState","useCallback","updater","type","instanceRef","useRef","assign","current","columnsBeforeHeaderGroups","columnsBeforeHeaderGroupsDeps","useBeforeDimensions","useMain","useRows","prepareRow","getTableProps","getTableBodyProps","getRowProps","getHeaderGroupProps","getHeaderProps","getCellProps","_React$useMemo","flatRows","accessRow","originalRow","parentPath","original","rowID","cells","unpreparedAccessWarning","values","_React$useMemo2","rows","flatHeaders","all","calculateDimensions","render","userProps","colSpan","columnPathStr","totalColumnsWidth","calculateHeaderWidths","left","sumTotalWidth","subHeaders","totalLeft","totalWidth","Math","min","max","actions","addActions","acts","action","expanded","string","text","filterValue","rowValue","toLowerCase","autoRemove","exactText","exactTextCase","includesAll","every","exact","equals","between","Infinity","temp","filters","shape","disableFilters","Filter","any","groupBy","aggregate","oneOfType","disableGrouping","Aggregated","reSplitAlphaNumeric","compareBasic","b","getRowValueByColumnID","columnID","isNaN","sortTypes","freeze","alphanumeric","aa","shift","bb","an","parseInt","bn","combo","datetime","getTime","basic","sortBy","sortType","sortDescFirst","propTypes$4","disableSorting","orderByFn","manualSorting","disableMultiSort","isMultiSortEvent","maxMultiSortColCount","number","disableSortRemove","disableMultiRemove","useSortBy","useMain$3","_instance$orderByFn","userSortTypes","_instance$isMultiSort","shiftKey","_instance$maxMultiSor","getSortByToggleProps","toggleSortBy","multi","find","existingSortBy","existingIndex","hasDescDefined","newSortBy","splice","sortByChange","columnDisableSorting","canSort","clearSorting","onClick","persist","title","columnSort","isSorted","sortedIndex","isSortedDesc","sortedRows","availableSortBy","sortData","sortedData","sortMethod","sortInverted","preSortedRows","pageSize","pageIndex","selectedRowPaths","rowState","columnOrder","columnResizing","columnWidths","canResize"],"mappings":"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","file":"static/js/3.4abda8b2.chunk.js","sourcesContent":["import React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar defaultColumn = {\n  Cell: function Cell(_ref) {\n    var _ref$cell$value = _ref.cell.value,\n        value = _ref$cell$value === void 0 ? '' : _ref$cell$value;\n    return String(value);\n  },\n  show: true,\n  width: 150,\n  minWidth: 0,\n  maxWidth: Number.MAX_SAFE_INTEGER // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n\n};\nvar safeUseLayoutEffect = typeof window !== 'undefined' && process.env.NODE_ENV === 'production' ? React.useLayoutEffect : React.useEffect; // Find the depth of the columns\n\nfunction findMaxDepth(columns) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return columns.reduce(function (prev, curr) {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1));\n    }\n\n    return depth;\n  }, 0);\n}\n\nfunction decorateColumn(column, userDefaultColumn, parent, depth, index) {\n  // Apply the userDefaultColumn\n  column = _objectSpread2({}, defaultColumn, {}, userDefaultColumn, {}, column); // First check for string accessor\n\n  var _column = column,\n      id = _column.id,\n      accessor = _column.accessor,\n      Header = _column.Header;\n\n  if (typeof accessor === 'string') {\n    id = id || accessor;\n    var accessorPath = accessor.split('.');\n\n    accessor = function accessor(row) {\n      return getBy(row, accessorPath);\n    };\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header;\n  }\n\n  if (!id && column.columns) {\n    console.error(column);\n    throw new Error('A column ID (or unique \"Header\" value) is required!');\n  }\n\n  if (!id) {\n    console.error(column);\n    throw new Error('A column ID (or string accessor) is required!');\n  }\n\n  column = _objectSpread2({\n    // Make sure there is a fallback header, just in case\n    Header: function Header() {\n      return React.createElement(React.Fragment, null, \"\\xA0\");\n    }\n  }, column, {\n    // Materialize and override this stuff\n    id: id,\n    accessor: accessor,\n    parent: parent,\n    depth: depth,\n    index: index\n  });\n  return column;\n} // Build the visible columns, headers and flat column list\n\n\nfunction decorateColumnTree(columns, defaultColumn, parent) {\n  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return columns.map(function (column, columnIndex) {\n    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex);\n\n    if (column.columns) {\n      column.columns = decorateColumnTree(column.columns, defaultColumn, column, depth + 1);\n    }\n\n    return column;\n  });\n} // Build the header groups from the bottom up\n\n\nfunction makeHeaderGroups(flatColumns, defaultColumn) {\n  var headerGroups = []; // Build each header group from the bottom up\n\n  var buildGroup = function buildGroup(columns, depth) {\n    var headerGroup = {\n      headers: []\n    };\n    var parentColumns = []; // Do any of these columns have parents?\n\n    var hasParents = columns.some(function (col) {\n      return col.parent;\n    });\n    columns.forEach(function (column) {\n      // Are we the first column in this group?\n      var isFirst = !parentColumns.length; // What is the latest (last) parent column?\n\n      var latestParentColumn = [].concat(parentColumns).reverse()[0]; // If the column has a parent, add it if necessary\n\n      if (column.parent) {\n        var similarParentColumns = parentColumns.filter(function (d) {\n          return d.originalID === column.parent.id;\n        });\n\n        if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n          parentColumns.push(_objectSpread2({}, column.parent, {\n            originalID: column.parent.id,\n            id: [column.parent.id, similarParentColumns.length].join('_')\n          }));\n        }\n      } else if (hasParents) {\n        // If other columns have parents, we'll need to add a place holder if necessary\n        var originalID = [column.id, 'placeholder'].join('_');\n\n        var _similarParentColumns = parentColumns.filter(function (d) {\n          return d.originalID === originalID;\n        });\n\n        var placeholderColumn = decorateColumn({\n          originalID: originalID,\n          id: [column.id, 'placeholder', _similarParentColumns.length].join('_'),\n          placeholderOf: column\n        }, defaultColumn);\n\n        if (isFirst || latestParentColumn.originalID !== placeholderColumn.originalID) {\n          parentColumns.push(placeholderColumn);\n        }\n      } // Establish the new headers[] relationship on the parent\n\n\n      if (column.parent || hasParents) {\n        latestParentColumn = [].concat(parentColumns).reverse()[0];\n        latestParentColumn.headers = latestParentColumn.headers || [];\n\n        if (!latestParentColumn.headers.includes(column)) {\n          latestParentColumn.headers.push(column);\n        }\n      }\n\n      column.totalHeaderCount = column.headers ? column.headers.reduce(function (sum, header) {\n        return sum + header.totalHeaderCount;\n      }, 0) : 1; // Leaf node columns take up at least one count\n\n      headerGroup.headers.push(column);\n    });\n    headerGroups.push(headerGroup);\n\n    if (parentColumns.length) {\n      buildGroup(parentColumns, depth + 1);\n    }\n  };\n\n  buildGroup(flatColumns, 0);\n  return headerGroups.reverse();\n}\n\nfunction determineHeaderVisibility(instance) {\n  var headers = instance.headers;\n\n  var handleColumn = function handleColumn(column, parentVisible) {\n    column.isVisible = parentVisible ? typeof column.show === 'function' ? column.show(instance) : !!column.show : false;\n    var totalVisibleHeaderCount = 0;\n\n    if (column.headers && column.headers.length) {\n      column.headers.forEach(function (subColumn) {\n        return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n      });\n    } else {\n      totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n    }\n\n    column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n    return totalVisibleHeaderCount;\n  };\n\n  var totalVisibleHeaderCount = 0;\n  headers.forEach(function (subHeader) {\n    return totalVisibleHeaderCount += handleColumn(subHeader, true);\n  });\n}\n\nfunction getBy(obj, path, def) {\n  if (!path) {\n    return obj;\n  }\n\n  var pathObj = makePathArray(path);\n  var val;\n\n  try {\n    val = pathObj.reduce(function (cursor, pathPart) {\n      return cursor[pathPart];\n    }, obj);\n  } catch (e) {// continue regardless of error\n  }\n\n  return typeof val !== 'undefined' ? val : def;\n}\n\nfunction defaultOrderByFn(arr, funcs, dirs) {\n  return _toConsumableArray(arr).sort(function (rowA, rowB) {\n    for (var i = 0; i < funcs.length; i += 1) {\n      var sortFn = funcs[i];\n      var desc = dirs[i] === false || dirs[i] === 'desc';\n      var sortInt = sortFn(rowA, rowB);\n\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt;\n      }\n    }\n\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n  });\n}\n\nfunction getFirstDefined() {\n  for (var i = 0; i < arguments.length; i += 1) {\n    if (typeof (i < 0 || arguments.length <= i ? undefined : arguments[i]) !== 'undefined') {\n      return i < 0 || arguments.length <= i ? undefined : arguments[i];\n    }\n  }\n}\n\nfunction defaultGroupByFn(rows, columnID) {\n  return rows.reduce(function (prev, row, i) {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    var resKey = \"\".concat(row.values[columnID]);\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n    prev[resKey].push(row);\n    return prev;\n  }, {});\n}\n\nfunction getElementDimensions(element) {\n  var rect = element.getBoundingClientRect();\n  var style = window.getComputedStyle(element);\n  var margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  };\n  var padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  };\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(rect.width + margins.left + margins.right + padding.left + padding.right),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  };\n}\n\nfunction flexRender(Comp, props) {\n  return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n}\n\nfunction isClassComponent(component) {\n  return typeof component === 'function' && !!function () {\n    var proto = Object.getPrototypeOf(component);\n    return proto.prototype && proto.prototype.isReactComponent;\n  }();\n}\n\nfunction isFunctionComponent(component) {\n  return typeof component === 'function';\n}\n\nfunction isReactComponent(component) {\n  return isClassComponent(component) || isFunctionComponent(component);\n}\n\nvar mergeProps = function mergeProps() {\n  var props = {};\n\n  for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {\n    groups[_key] = arguments[_key];\n  }\n\n  groups.forEach(function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$style = _ref2.style,\n        style = _ref2$style === void 0 ? {} : _ref2$style,\n        className = _ref2.className,\n        rest = _objectWithoutProperties(_ref2, [\"style\", \"className\"]);\n\n    props = _objectSpread2({}, props, {}, rest, {\n      style: _objectSpread2({}, props.style || {}, {}, style),\n      className: [props.className, className].filter(Boolean).join(' ')\n    });\n  });\n  return props;\n};\n\nvar applyHooks = function applyHooks(hooks, initial) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return hooks.reduce(function (prev, next) {\n    var nextValue = next.apply(void 0, [prev].concat(args));\n\n    if (typeof nextValue === 'undefined') {\n      throw new Error('React Table: A hook just returned undefined! This is not allowed.');\n    }\n\n    return nextValue;\n  }, initial);\n};\n\nvar applyPropHooks = function applyPropHooks(hooks) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return hooks.reduce(function (prev, next) {\n    return mergeProps(prev, next.apply(void 0, args));\n  }, {});\n};\n\nvar warnUnknownProps = function warnUnknownProps(props) {\n  if (Object.keys(props).length) {\n    throw new Error(\"Unknown options passed to useReactTable:\\n\\n\".concat(JSON.stringify(props, null, 2)));\n  }\n};\n\nfunction sum(arr) {\n  return arr.reduce(function (prev, curr) {\n    return prev + curr;\n  }, 0);\n}\n\nfunction isFunction(a) {\n  if (typeof a === 'function') {\n    return a;\n  }\n}\n\nfunction flattenBy(columns, childKey) {\n  var flatColumns = [];\n\n  var recurse = function recurse(columns) {\n    columns.forEach(function (d) {\n      if (!d[childKey]) {\n        flatColumns.push(d);\n      } else {\n        recurse(d[childKey]);\n      }\n    });\n  };\n\n  recurse(columns);\n  return flatColumns;\n}\n\nfunction ensurePluginOrder(plugins, befores, pluginName, afters) {\n  var pluginIndex = plugins.findIndex(function (plugin) {\n    return plugin.pluginName === pluginName;\n  });\n\n  if (pluginIndex === -1) {\n    throw new Error(\"The plugin \".concat(pluginName, \" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \").concat(pluginName, \".pluginName = '\").concat(pluginName, \"'\\n\"));\n  }\n\n  befores.forEach(function (before) {\n    var beforeIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === before;\n    });\n\n    if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n      throw new Error(\"React Table: The \".concat(pluginName, \" plugin hook must be placed after the \").concat(before, \" plugin hook!\"));\n    }\n  });\n  afters.forEach(function (after) {\n    var afterIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === after;\n    });\n\n    if (afterIndex > -1 && afterIndex < pluginIndex) {\n      throw new Error(\"React Table: The \".concat(pluginName, \" plugin hook must be placed before the \").concat(after, \" plugin hook!\"));\n    }\n  });\n}\n\nfunction expandRows(rows, _ref3) {\n  var manualExpandedKey = _ref3.manualExpandedKey,\n      expanded = _ref3.expanded,\n      _ref3$expandSubRows = _ref3.expandSubRows,\n      expandSubRows = _ref3$expandSubRows === void 0 ? true : _ref3$expandSubRows;\n  var expandedRows = [];\n\n  var handleRow = function handleRow(row) {\n    var key = row.path.join('.');\n    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded.includes(key);\n    row.canExpand = row.subRows && !!row.subRows.length;\n    expandedRows.push(row);\n\n    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rows.forEach(handleRow);\n  return expandedRows;\n} //\n\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj) // remove all periods in parts\n  .map(function (d) {\n    return String(d).replace('.', '_');\n  }) // join parts using period\n  .join('.') // replace brackets with periods\n  .replace(/\\[/g, '.').replace(/\\]/g, '') // split it back out on periods\n  .split('.');\n}\n\nfunction flattenDeep(arr) {\n  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!Array.isArray(arr)) {\n    newArr.push(arr);\n  } else {\n    for (var i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr);\n    }\n  }\n\n  return newArr;\n}\n\nvar utils =\n/*#__PURE__*/\nObject.freeze({\n  defaultColumn: defaultColumn,\n  safeUseLayoutEffect: safeUseLayoutEffect,\n  findMaxDepth: findMaxDepth,\n  decorateColumn: decorateColumn,\n  decorateColumnTree: decorateColumnTree,\n  makeHeaderGroups: makeHeaderGroups,\n  determineHeaderVisibility: determineHeaderVisibility,\n  getBy: getBy,\n  defaultOrderByFn: defaultOrderByFn,\n  getFirstDefined: getFirstDefined,\n  defaultGroupByFn: defaultGroupByFn,\n  getElementDimensions: getElementDimensions,\n  flexRender: flexRender,\n  mergeProps: mergeProps,\n  applyHooks: applyHooks,\n  applyPropHooks: applyPropHooks,\n  warnUnknownProps: warnUnknownProps,\n  sum: sum,\n  isFunction: isFunction,\n  flattenBy: flattenBy,\n  ensurePluginOrder: ensurePluginOrder,\n  expandRows: expandRows\n});\nvar propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  columns: PropTypes.arrayOf(PropTypes.object).isRequired,\n  defaultColumn: PropTypes.object,\n  getSubRows: PropTypes.func,\n  getRowID: PropTypes.func,\n  debug: PropTypes.bool\n};\nvar renderErr = 'You must specify a valid render component. This could be \"column.Cell\", \"column.Header\", \"column.Filter\", \"column.Aggregated\" or any other custom renderer component.';\nvar defaultState = {};\nvar defaultInitialState = {};\nvar defaultColumnInstance = {};\n\nvar defaultReducer = function defaultReducer(old, newState) {\n  return newState;\n};\n\nvar defaultGetSubRows = function defaultGetSubRows(row, index) {\n  return row.subRows || [];\n};\n\nvar defaultGetRowID = function defaultGetRowID(row, index) {\n  return index;\n};\n\nvar useTable = function useTable(props) {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable'); // Destructure props\n\n  var data = props.data,\n      userColumns = props.columns,\n      _props$initialState = props.initialState,\n      initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,\n      userState = props.state,\n      _props$defaultColumn = props.defaultColumn,\n      defaultColumn$$1 = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,\n      _props$getSubRows = props.getSubRows,\n      getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,\n      _props$getRowID = props.getRowID,\n      getRowID = _props$getRowID === void 0 ? defaultGetRowID : _props$getRowID,\n      _props$reducer = props.reducer,\n      reducer = _props$reducer === void 0 ? defaultReducer : _props$reducer,\n      debug = props.debug;\n  debug = process.env.NODE_ENV === 'production' ? false : debug; // But use the users table state if provided\n\n  var _React$useState = React.useState(_objectSpread2({}, defaultState, {}, initialState)),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      originalState = _React$useState2[0],\n      originalSetState = _React$useState2[1];\n\n  var state = React.useMemo(function () {\n    if (userState) {\n      var newState = _objectSpread2({}, originalState);\n\n      Object.keys(userState).forEach(function (key) {\n        newState[key] = userState[key];\n      });\n      return newState;\n    }\n\n    return originalState;\n  }, [originalState, userState]);\n  var setState = React.useCallback(function (updater, type) {\n    return originalSetState(function (old) {\n      var newState = typeof updater === 'function' ? updater(old) : updater;\n      return reducer(old, newState, type);\n    });\n  }, [reducer]); // The table instance ref\n\n  var instanceRef = React.useRef({});\n\n  for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    plugins[_key - 1] = arguments[_key];\n  }\n\n  Object.assign(instanceRef.current, _objectSpread2({}, props, {\n    data: data,\n    // The raw data\n    state: state,\n    setState: setState,\n    // The resolved table state\n    plugins: plugins,\n    // All resolved plugins\n    hooks: {\n      columnsBeforeHeaderGroups: [],\n      columnsBeforeHeaderGroupsDeps: [],\n      useBeforeDimensions: [],\n      useMain: [],\n      useRows: [],\n      prepareRow: [],\n      getTableProps: [],\n      getTableBodyProps: [],\n      getRowProps: [],\n      getHeaderGroupProps: [],\n      getHeaderProps: [],\n      getCellProps: []\n    }\n  })); // Allow plugins to register hooks\n\n  if (process.env.NODE_ENV === 'development' && debug) console.time('plugins');\n  plugins.filter(Boolean).forEach(function (plugin) {\n    plugin(instanceRef.current.hooks);\n  });\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('plugins'); // Decorate All the columns\n\n  var columns = React.useMemo(function () {\n    return decorateColumnTree(userColumns, defaultColumn$$1);\n  }, [defaultColumn$$1, userColumns]); // Get the flat list of all columns andllow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n\n  var flatColumns = React.useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.columnsBeforeHeaderGroups');\n    var newColumns = applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroups, flattenBy(columns, 'columns'), instanceRef.current);\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.columnsBeforeHeaderGroups');\n    return newColumns;\n  }, [columns, debug].concat(_toConsumableArray(applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroupsDeps, [], instanceRef.current)))); // Make the headerGroups\n\n  var headerGroups = React.useMemo(function () {\n    return makeHeaderGroups(flatColumns, defaultColumn$$1);\n  }, [defaultColumn$$1, flatColumns]);\n  var headers = React.useMemo(function () {\n    return headerGroups[0].headers;\n  }, [headerGroups]);\n  Object.assign(instanceRef.current, {\n    columns: columns,\n    flatColumns: flatColumns,\n    headerGroups: headerGroups,\n    headers: headers\n  }); // Access the row model\n\n  var _React$useMemo = React.useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.time('getAccessedRows');\n    var flatRows = []; // Access the row's data\n\n    var accessRow = function accessRow(originalRow, i) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Keep the original reference around\n\n      var original = originalRow;\n      var rowID = getRowID(originalRow, i); // Make the new path for the row\n\n      var path = [].concat(_toConsumableArray(parentPath), [rowID]);\n      var row = {\n        original: original,\n        index: i,\n        path: path,\n        // used to create a key for each row even if not nested\n        depth: depth,\n        cells: [{}] // This is a dummy cell\n\n      };\n      flatRows.push(row); // Process any subRows\n\n      var subRows = getSubRows(originalRow, i);\n\n      if (subRows) {\n        row.subRows = subRows.map(function (d, i) {\n          return accessRow(d, i, depth + 1, path);\n        });\n      } // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n\n\n      var unpreparedAccessWarning = function unpreparedAccessWarning() {\n        throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');\n      };\n\n      row.cells.map = unpreparedAccessWarning;\n      row.cells.filter = unpreparedAccessWarning;\n      row.cells.forEach = unpreparedAccessWarning;\n      row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n\n      row.values = {};\n      flatColumns.forEach(function (column) {\n        row.values[column.id] = column.accessor ? column.accessor(originalRow, i, {\n          subRows: subRows,\n          depth: depth,\n          data: data\n        }) : undefined;\n      });\n      return row;\n    }; // Use the resolved data\n\n\n    var accessedData = data.map(function (d, i) {\n      return accessRow(d, i);\n    });\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('getAccessedRows');\n    return [accessedData, flatRows];\n  }, [debug, data, getRowID, getSubRows, flatColumns]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      rows = _React$useMemo2[0],\n      flatRows = _React$useMemo2[1];\n\n  instanceRef.current.rows = rows;\n  instanceRef.current.flatRows = flatRows; // Determine column visibility\n\n  determineHeaderVisibility(instanceRef.current); // Provide a flat header list for utilities\n\n  instanceRef.current.flatHeaders = headerGroups.reduce(function (all, headerGroup) {\n    return [].concat(_toConsumableArray(all), _toConsumableArray(headerGroup.headers));\n  }, []);\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useBeforeDimensions');\n  instanceRef.current = applyHooks(instanceRef.current.hooks.useBeforeDimensions, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useBeforeDimensions');\n  calculateDimensions(instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useMain');\n  instanceRef.current = applyHooks(instanceRef.current.hooks.useMain, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useMain'); // Each materialized header needs to be assigned a render function and other\n  // prop getter properties here.\n\n  instanceRef.current.flatHeaders.forEach(function (column) {\n    // Give columns/headers rendering power\n    column.render = function (type) {\n      var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var Comp = typeof type === 'string' ? column[type] : type;\n\n      if (typeof Comp === 'undefined') {\n        throw new Error(renderErr);\n      }\n\n      return flexRender(Comp, _objectSpread2({}, instanceRef.current, {\n        column: column\n      }, userProps));\n    }; // Give columns/headers a default getHeaderProps\n\n\n    column.getHeaderProps = function (props) {\n      return mergeProps({\n        key: ['header', column.id].join('_'),\n        colSpan: column.totalVisibleHeaderCount\n      }, applyPropHooks(instanceRef.current.hooks.getHeaderProps, column, instanceRef.current), props);\n    };\n  });\n  instanceRef.current.headerGroups.forEach(function (headerGroup, i) {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(function (header) {\n      var recurse = function recurse(headers) {\n        return headers.filter(function (header) {\n          if (header.headers) {\n            return recurse(header.headers);\n          }\n\n          return header.isVisible;\n        }).length;\n      };\n\n      if (header.headers) {\n        return recurse(header.headers);\n      }\n\n      return header.isVisible;\n    }); // Give headerGroups getRowProps\n\n    if (headerGroup.headers.length) {\n      headerGroup.getHeaderGroupProps = function () {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return mergeProps({\n          key: [\"header\".concat(i)].join('_')\n        }, applyPropHooks(instanceRef.current.hooks.getHeaderGroupProps, headerGroup, instanceRef.current), props);\n      };\n\n      return true;\n    }\n  }); // Run the rows (this could be a dangerous hook with a ton of data)\n\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useRows');\n  instanceRef.current.rows = applyHooks(instanceRef.current.hooks.useRows, instanceRef.current.rows, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useRows'); // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  instanceRef.current.prepareRow = React.useCallback(function (row) {\n    row.getRowProps = function (props) {\n      return mergeProps({\n        key: ['row'].concat(_toConsumableArray(row.path)).join('_')\n      }, applyPropHooks(instanceRef.current.hooks.getRowProps, row, instanceRef.current), props);\n    }; // Build the visible cells for each row\n\n\n    row.cells = instanceRef.current.flatColumns.filter(function (d) {\n      return d.isVisible;\n    }).map(function (column) {\n      var cell = {\n        column: column,\n        row: row,\n        value: row.values[column.id] // Give each cell a getCellProps base\n\n      };\n\n      cell.getCellProps = function (props) {\n        var columnPathStr = [].concat(_toConsumableArray(row.path), [column.id]).join('_');\n        return mergeProps({\n          key: ['cell', columnPathStr].join('_')\n        }, applyPropHooks(instanceRef.current.hooks.getCellProps, cell, instanceRef.current), props);\n      }; // Give each cell a renderer function (supports multiple renderers)\n\n\n      cell.render = function (type) {\n        var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var Comp = typeof type === 'string' ? column[type] : type;\n\n        if (typeof Comp === 'undefined') {\n          throw new Error(renderErr);\n        }\n\n        return flexRender(Comp, _objectSpread2({}, instanceRef.current, {\n          column: column,\n          row: row,\n          cell: cell\n        }, userProps));\n      };\n\n      return cell;\n    }); // need to apply any row specific hooks (useExpanded requires this)\n\n    applyHooks(instanceRef.current.hooks.prepareRow, row, instanceRef.current);\n  }, []);\n\n  instanceRef.current.getTableProps = function (userProps) {\n    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableProps, instanceRef.current), userProps);\n  };\n\n  instanceRef.current.getTableBodyProps = function (userProps) {\n    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableBodyProps, instanceRef.current), userProps);\n  };\n\n  return instanceRef.current;\n};\n\nfunction calculateDimensions(instance) {\n  var headers = instance.headers;\n  instance.totalColumnsWidth = calculateHeaderWidths(headers);\n}\n\nfunction calculateHeaderWidths(headers) {\n  var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var sumTotalWidth = 0;\n  headers.forEach(function (header) {\n    var subHeaders = header.headers;\n    header.totalLeft = left;\n\n    if (subHeaders && subHeaders.length) {\n      header.totalWidth = calculateHeaderWidths(subHeaders, left);\n    } else {\n      header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n    }\n\n    left += header.totalWidth;\n    sumTotalWidth += header.totalWidth;\n  });\n  return sumTotalWidth;\n}\n\nvar actions = {};\n\nvar addActions = function addActions() {\n  for (var _len = arguments.length, acts = new Array(_len), _key = 0; _key < _len; _key++) {\n    acts[_key] = arguments[_key];\n  }\n\n  acts.forEach(function (action) {\n    // Action values are formatted this way to discourage\n    // you (the dev) from interacting with them in any way\n    // other than importing `{ actions } from 'react-table'`\n    // and referencing an action via `actions[actionName]`\n    actions[action] = \"React Table Action: \".concat(action);\n  });\n};\n\ndefaultState.expanded = [];\naddActions('toggleExpanded', 'useExpanded');\nvar propTypes$1 = {\n  manualExpandedKey: PropTypes.string,\n  paginateExpandedRows: PropTypes.bool\n};\n\nvar useExpanded = function useExpanded(hooks) {\n  hooks.getExpandedToggleProps = [];\n  hooks.useMain.push(useMain);\n};\n\nuseExpanded.pluginName = 'useExpanded';\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes$1, instance, 'property', 'useExpanded');\n  var debug = instance.debug,\n      rows = instance.rows,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      hooks = instance.hooks,\n      expanded = instance.state.expanded,\n      setState = instance.setState;\n\n  var toggleExpandedByPath = function toggleExpandedByPath(path, set) {\n    var key = path.join('.');\n    return setState(function (old) {\n      var exists = old.expanded.includes(key);\n      var shouldExist = typeof set !== 'undefined' ? set : !exists;\n      var newExpanded = new Set(old.expanded);\n\n      if (!exists && shouldExist) {\n        newExpanded.add(key);\n      } else if (exists && !shouldExist) {\n        newExpanded.delete(key);\n      } else {\n        return old;\n      }\n\n      return _objectSpread2({}, old, {\n        expanded: _toConsumableArray(newExpanded.values())\n      });\n    }, actions.toggleExpanded);\n  };\n\n  hooks.prepareRow.push(function (row) {\n    row.toggleExpanded = function (set) {\n      return toggleExpandedByPath(row.path, set);\n    };\n\n    row.getExpandedToggleProps = function (props) {\n      return mergeProps({\n        onClick: function onClick(e) {\n          e.persist();\n          row.toggleExpanded();\n        },\n        style: {\n          cursor: 'pointer'\n        },\n        title: 'Toggle Expanded'\n      }, applyPropHooks(instance.hooks.getExpandedToggleProps, row, instance), props);\n    };\n\n    return row;\n  });\n  var expandedRows = useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getExpandedRows');\n\n    if (paginateExpandedRows) {\n      return expandRows(rows, {\n        manualExpandedKey: manualExpandedKey,\n        expanded: expanded,\n        expandSubRows: expandSubRows\n      });\n    }\n\n    return rows;\n  }, [debug, paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);\n  var expandedDepth = findExpandedDepth(expanded);\n  return _objectSpread2({}, instance, {\n    toggleExpandedByPath: toggleExpandedByPath,\n    expandedDepth: expandedDepth,\n    rows: expandedRows\n  });\n}\n\nfunction findExpandedDepth(expanded) {\n  var maxDepth = 0;\n  expanded.forEach(function (key) {\n    var path = key.split('.');\n    maxDepth = Math.max(maxDepth, path.length);\n  });\n  return maxDepth;\n}\n\nvar text = function text(rows, id, filterValue) {\n  rows = rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n  });\n  return rows;\n};\n\ntext.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactText = function exactText(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n  });\n};\n\nexactText.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactTextCase = function exactTextCase(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n  });\n};\n\nexactTextCase.autoRemove = function (val) {\n  return !val;\n};\n\nvar includes = function includes(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return filterValue.includes(rowValue);\n  });\n};\n\nincludes.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar includesAll = function includesAll(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue && rowValue.length && filterValue.every(function (val) {\n      return rowValue.includes(val);\n    });\n  });\n};\n\nincludesAll.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar exact = function exact(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue === filterValue;\n  });\n};\n\nexact.autoRemove = function (val) {\n  return typeof val === 'undefined';\n};\n\nvar equals = function equals(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n\n    return rowValue == filterValue;\n  });\n};\n\nequals.autoRemove = function (val) {\n  return val == null;\n};\n\nvar between = function between(rows, id, filterValue) {\n  var _ref = filterValue || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n\n  if (min > max) {\n    var temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue >= min && rowValue <= max;\n  });\n};\n\nbetween.autoRemove = function (val) {\n  return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';\n};\n\nvar filterTypes =\n/*#__PURE__*/\nObject.freeze({\n  text: text,\n  exactText: exactText,\n  exactTextCase: exactTextCase,\n  includes: includes,\n  includesAll: includesAll,\n  exact: exact,\n  equals: equals,\n  between: between\n});\ndefaultState.filters = {};\naddActions('setFilter', 'setAllFilters');\nvar propTypes$2 = {\n  columns: PropTypes.arrayOf(PropTypes.shape({\n    disableFilters: PropTypes.bool,\n    Filter: PropTypes.any\n  })),\n  manualFilters: PropTypes.bool\n};\n\nvar useFilters = function useFilters(hooks) {\n  hooks.useMain.push(useMain$1);\n};\n\nuseFilters.pluginName = 'useFilters';\n\nfunction useMain$1(instance) {\n  PropTypes.checkPropTypes(propTypes$2, instance, 'property', 'useFilters');\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      flatColumns = instance.flatColumns,\n      userFilterTypes = instance.filterTypes,\n      manualFilters = instance.manualFilters,\n      disableFilters = instance.disableFilters,\n      filters = instance.state.filters,\n      setState = instance.setState;\n  var preFilteredRows = rows;\n  var preFilteredFlatRows = flatRows;\n\n  var setFilter = function setFilter(id, updater) {\n    var column = flatColumns.find(function (d) {\n      return d.id === id;\n    });\n\n    if (!column) {\n      throw new Error(\"React-Table: Could not find a column with id: \".concat(id));\n    }\n\n    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n    return setState(function (old) {\n      var newFilter = typeof updater === 'function' ? updater(old.filters[id]) : updater; //\n\n      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n        var _old$filters = old.filters,\n            remove = _old$filters[id],\n            newFilters = _objectWithoutProperties(_old$filters, [id].map(_toPropertyKey));\n\n        return _objectSpread2({}, old, {\n          filters: newFilters\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        filters: _objectSpread2({}, old.filters, _defineProperty({}, id, newFilter))\n      });\n    }, actions.setFilter);\n  };\n\n  var setAllFilters = function setAllFilters(updater) {\n    return setState(function (old) {\n      var newFilters = typeof updater === 'function' ? updater(old) : updater; // Filter out undefined values\n\n      Object.keys(newFilters).forEach(function (id) {\n        var newFilter = newFilters[id];\n        var column = flatColumns.find(function (d) {\n          return d.id === id;\n        });\n        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n          delete newFilters[id];\n        }\n      });\n      return _objectSpread2({}, old, {\n        filters: newFilters\n      });\n    }, actions.setAllFilters);\n  };\n\n  flatColumns.forEach(function (column) {\n    var id = column.id,\n        accessor = column.accessor,\n        columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n\n    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : false; // Provide the column a way of updating the filter value\n\n    column.setFilter = function (val) {\n      return setFilter(column.id, val);\n    }; // Provide the current filter value to the column for\n    // convenience\n\n\n    column.filterValue = filters[id];\n  }); // TODO: Create a filter cache for incremental high speed multi-filtering\n  // This gets pretty complicated pretty fast, since you have to maintain a\n  // cache for each row group (top-level rows, and each row's recursive subrows)\n  // This would make multi-filtering a lot faster though. Too far?\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualFilters || !Object.keys(filters).length) {\n      return {\n        filteredRows: rows,\n        filteredFlatRows: flatRows\n      };\n    }\n\n    var filteredFlatRows = [];\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getFilteredRows'); // Filters top level and nested rows\n\n    var filterRows = function filterRows(rows) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var filteredRows = rows;\n      filteredRows = Object.entries(filters).reduce(function (filteredSoFar, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            columnID = _ref2[0],\n            filterValue = _ref2[1]; // Find the filters column\n\n\n        var column = flatColumns.find(function (d) {\n          return d.id === columnID;\n        });\n\n        if (!column) {\n          return filteredSoFar;\n        }\n\n        if (depth === 0) {\n          column.preFilteredRows = filteredSoFar;\n        }\n\n        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (!filterMethod) {\n          console.warn(\"Could not find a valid 'column.filter' for column with the ID: \".concat(column.id, \".\"));\n          return filteredSoFar;\n        } // Pass the rows, id, filterValue and column to the filterMethod\n        // to get the filtered rows back\n\n\n        column.filteredRows = filterMethod(filteredSoFar, columnID, filterValue, column);\n        return column.filteredRows;\n      }, rows); // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n\n      filteredRows = filteredRows.map(function (row) {\n        filteredFlatRows.push(row);\n\n        if (!row.subRows) {\n          return row;\n        }\n\n        return _objectSpread2({}, row, {\n          subRows: row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows\n        });\n      });\n      return filteredRows;\n    };\n\n    return {\n      filteredRows: filterRows(rows),\n      filteredFlatRows: filteredFlatRows\n    };\n  }, [manualFilters, filters, debug, rows, flatRows, flatColumns, userFilterTypes]),\n      filteredRows = _React$useMemo.filteredRows,\n      filteredFlatRows = _React$useMemo.filteredFlatRows;\n\n  React.useMemo(function () {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    var nonFilteredColumns = flatColumns.filter(function (column) {\n      return !Object.keys(filters).includes(column.id);\n    }); // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n\n    nonFilteredColumns.forEach(function (column) {\n      column.preFilteredRows = filteredRows;\n      column.filteredRows = filteredRows;\n    });\n  }, [filteredRows, filters, flatColumns]);\n  return _objectSpread2({}, instance, {\n    setFilter: setFilter,\n    setAllFilters: setAllFilters,\n    preFilteredRows: preFilteredRows,\n    preFilteredFlatRows: preFilteredFlatRows,\n    rows: filteredRows,\n    flatRows: filteredFlatRows\n  });\n}\n\nfunction shouldAutoRemove(autoRemove, value) {\n  return autoRemove ? autoRemove(value) : typeof value === 'undefined';\n}\n\nfunction getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n}\n\nfunction sum$1(values, rows) {\n  return values.reduce(function (sum, next) {\n    return sum + next;\n  }, 0);\n}\n\nfunction average(values, rows) {\n  return Math.round(sum$1(values, rows) / values.length * 100) / 100;\n}\n\nfunction median(values) {\n  var min = values[0] || '';\n  var max = values[0] || '';\n  values.forEach(function (value) {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n  return (min + max) / 2;\n}\n\nfunction uniqueCount(values) {\n  return new Set(values).size;\n}\n\nfunction count(values) {\n  return values.length;\n}\n\nvar aggregations =\n/*#__PURE__*/\nObject.freeze({\n  sum: sum$1,\n  average: average,\n  median: median,\n  uniqueCount: uniqueCount,\n  count: count\n});\ndefaultState.groupBy = [];\naddActions('toggleGroupBy');\nvar propTypes$3 = {\n  // General\n  columns: PropTypes.arrayOf(PropTypes.shape({\n    aggregate: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.string]))]),\n    disableGrouping: PropTypes.bool,\n    Aggregated: PropTypes.any\n  })),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  disableGrouping: PropTypes.bool,\n  aggregations: PropTypes.object\n};\n\nvar useGroupBy = function useGroupBy(hooks) {\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups);\n  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {\n    deps.push(instance.state.groupBy);\n    return deps;\n  });\n  hooks.useMain.push(useMain$2);\n};\n\nuseGroupBy.pluginName = 'useGroupBy';\n\nfunction columnsBeforeHeaderGroups(flatColumns, _ref) {\n  var groupBy = _ref.state.groupBy; // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  var groupByColumns = groupBy.map(function (g) {\n    return flatColumns.find(function (col) {\n      return col.id === g;\n    });\n  });\n  var nonGroupByColumns = flatColumns.filter(function (col) {\n    return !groupBy.includes(col.id);\n  }); // If a groupByBoundary column is found, place the groupBy's after it\n\n  var groupByBoundaryColumnIndex = flatColumns.findIndex(function (column) {\n    return column.groupByBoundary;\n  }) + 1;\n  return [].concat(_toConsumableArray(nonGroupByColumns.slice(0, groupByBoundaryColumnIndex)), _toConsumableArray(groupByColumns), _toConsumableArray(nonGroupByColumns.slice(groupByBoundaryColumnIndex)));\n}\n\nfunction useMain$2(instance) {\n  PropTypes.checkPropTypes(propTypes$3, instance, 'property', 'useGroupBy');\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatColumns = instance.flatColumns,\n      flatHeaders = instance.flatHeaders,\n      _instance$groupByFn = instance.groupByFn,\n      groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,\n      manualGroupBy = instance.manualGroupBy,\n      disableGrouping = instance.disableGrouping,\n      _instance$aggregation = instance.aggregations,\n      userAggregations = _instance$aggregation === void 0 ? {} : _instance$aggregation,\n      hooks = instance.hooks,\n      plugins = instance.plugins,\n      groupBy = instance.state.groupBy,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded']);\n  flatColumns.forEach(function (column) {\n    var id = column.id,\n        accessor = column.accessor,\n        columnDisableGrouping = column.disableGrouping;\n    column.isGrouped = groupBy.includes(id);\n    column.groupedIndex = groupBy.indexOf(id);\n    column.canGroupBy = accessor ? getFirstDefined(columnDisableGrouping, disableGrouping === true ? false : undefined, true) : false;\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = function () {\n        return toggleGroupBy(column.id);\n      };\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell;\n  });\n\n  var toggleGroupBy = function toggleGroupBy(id, toggle) {\n    return setState(function (old) {\n      var resolvedToggle = typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id);\n\n      if (resolvedToggle) {\n        return _objectSpread2({}, old, {\n          groupBy: [].concat(_toConsumableArray(groupBy), [id])\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        groupBy: groupBy.filter(function (d) {\n          return d !== id;\n        })\n      });\n    }, actions.toggleGroupBy);\n  };\n\n  hooks.getGroupByToggleProps = [];\n  flatHeaders.forEach(function (header) {\n    var canGroupBy = header.canGroupBy;\n\n    header.getGroupByToggleProps = function (props) {\n      return mergeProps({\n        onClick: canGroupBy ? function (e) {\n          e.persist();\n          header.toggleGroupBy();\n        } : undefined,\n        style: {\n          cursor: canGroupBy ? 'pointer' : undefined\n        },\n        title: 'Toggle GroupBy'\n      }, applyPropHooks(instance.hooks.getGroupByToggleProps, header, instance), props);\n    };\n  });\n  hooks.prepareRow.push(function (row) {\n    row.cells.forEach(function (cell) {\n      // Grouped cells are in the groupBy and the pivot cell for the row\n      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Repeated cells are any columns in the groupBy that are not grouped\n\n      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n\n      cell.isAggregated = !cell.isGrouped && !cell.isRepeatedValue && row.canExpand;\n    });\n    return row;\n  });\n  var groupedRows = useMemo(function () {\n    if (manualGroupBy || !groupBy.length) {\n      return rows;\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getGroupedRows'); // Find the columns that can or are aggregating\n    // Uses each column to aggregate rows into a single value\n\n    var aggregateRowsToValues = function aggregateRowsToValues(rows, isSourceRows) {\n      var values = {};\n      flatColumns.forEach(function (column) {\n        // Don't aggregate columns that are in the groupBy\n        if (groupBy.includes(column.id)) {\n          values[column.id] = rows[0] ? rows[0].values[column.id] : null;\n          return;\n        }\n\n        var columnValues = rows.map(function (d) {\n          return d.values[column.id];\n        });\n        var aggregator = column.aggregate;\n\n        if (Array.isArray(aggregator)) {\n          if (aggregator.length !== 2) {\n            console.info({\n              column: column\n            });\n            throw new Error(\"React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...\");\n          }\n\n          if (isSourceRows) {\n            aggregator = aggregator[1];\n          } else {\n            aggregator = aggregator[0];\n          }\n        }\n\n        var aggregateFn = typeof aggregator === 'function' ? aggregator : userAggregations[aggregator] || aggregations[aggregator];\n\n        if (aggregateFn) {\n          values[column.id] = aggregateFn(columnValues, rows);\n        } else if (aggregator) {\n          console.info({\n            column: column\n          });\n          throw new Error(\"React Table: Invalid aggregate option for column listed above\");\n        } else {\n          values[column.id] = null;\n        }\n      });\n      return values;\n    }; // Recursively group the data\n\n\n    var groupRecursively = function groupRecursively(rows) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []; // This is the last level, just return the rows\n\n      if (depth >= groupBy.length) {\n        return rows;\n      }\n\n      var columnID = groupBy[depth]; // Group the rows together for this level\n\n      var groupedRows = groupByFn(rows, columnID); // Recurse to sub rows before aggregation\n\n      groupedRows = Object.entries(groupedRows).map(function (_ref2, index) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            groupByVal = _ref3[0],\n            subRows = _ref3[1];\n\n        var path = [].concat(_toConsumableArray(parentPath), [\"\".concat(columnID, \":\").concat(groupByVal)]);\n        subRows = groupRecursively(subRows, depth + 1, path);\n        var values = aggregateRowsToValues(subRows, depth + 1 >= groupBy.length);\n        var row = {\n          isAggregated: true,\n          groupByID: columnID,\n          groupByVal: groupByVal,\n          values: values,\n          subRows: subRows,\n          depth: depth,\n          index: index,\n          path: path\n        };\n        return row;\n      });\n      return groupedRows;\n    }; // Assign the new data\n\n\n    return groupRecursively(rows);\n  }, [manualGroupBy, groupBy, debug, rows, flatColumns, userAggregations, groupByFn]);\n  return _objectSpread2({}, instance, {\n    toggleGroupBy: toggleGroupBy,\n    rows: groupedRows,\n    preGroupedRows: rows\n  });\n}\n\nvar reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\nvar alphanumeric = function alphanumeric(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID); // Force to strings (or \"\" for unsupported types)\n\n  a = toString(a);\n  b = toString(b); // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n\n  a = a.split(reSplitAlphaNumeric).filter(Boolean);\n  b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    var aa = a.shift();\n    var bb = b.shift();\n    var an = parseInt(aa, 10);\n    var bn = parseInt(bb, 10);\n    var combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n};\n\nfunction datetime(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID);\n  a = a.getTime();\n  b = b.getTime();\n  return compareBasic(a, b);\n}\n\nfunction basic(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID);\n  return compareBasic(a, b);\n} // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction getRowValueByColumnID(row, columnID) {\n  return row.values[columnID];\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n}\n\nvar sortTypes =\n/*#__PURE__*/\nObject.freeze({\n  alphanumeric: alphanumeric,\n  datetime: datetime,\n  basic: basic\n});\ndefaultState.sortBy = [];\ndefaultColumn.sortType = 'alphanumeric';\ndefaultColumn.sortDescFirst = false;\naddActions('sortByChange');\nvar propTypes$4 = {\n  // General\n  columns: PropTypes.arrayOf(PropTypes.shape({\n    sortType: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    sortDescFirst: PropTypes.bool,\n    disableSorting: PropTypes.bool\n  })),\n  orderByFn: PropTypes.func,\n  sortTypes: PropTypes.object,\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  disableMultiSort: PropTypes.bool,\n  isMultiSortEvent: PropTypes.func,\n  maxMultiSortColCount: PropTypes.number,\n  disableSortRemove: PropTypes.bool,\n  disableMultiRemove: PropTypes.bool\n};\n\nvar useSortBy = function useSortBy(hooks) {\n  hooks.useMain.push(useMain$3);\n};\n\nuseSortBy.pluginName = 'useSortBy';\n\nfunction useMain$3(instance) {\n  PropTypes.checkPropTypes(propTypes$4, instance, 'property', 'useSortBy');\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatColumns = instance.flatColumns,\n      _instance$orderByFn = instance.orderByFn,\n      orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,\n      userSortTypes = instance.sortTypes,\n      manualSorting = instance.manualSorting,\n      disableSorting = instance.disableSorting,\n      disableSortRemove = instance.disableSortRemove,\n      disableMultiRemove = instance.disableMultiRemove,\n      disableMultiSort = instance.disableMultiSort,\n      _instance$isMultiSort = instance.isMultiSortEvent,\n      isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {\n    return e.shiftKey;\n  } : _instance$isMultiSort,\n      _instance$maxMultiSor = instance.maxMultiSortColCount,\n      maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor,\n      flatHeaders = instance.flatHeaders,\n      hooks = instance.hooks,\n      sortBy = instance.state.sortBy,\n      setState = instance.setState,\n      plugins = instance.plugins;\n  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', []); // Add custom hooks\n\n  hooks.getSortByToggleProps = []; // Updates sorting based on a columnID, desc flag and multi flag\n\n  var toggleSortBy = function toggleSortBy(columnID, desc, multi) {\n    return setState(function (old) {\n      var sortBy = old.sortBy; // Find the column for this columnID\n\n      var column = flatColumns.find(function (d) {\n        return d.id === columnID;\n      });\n      var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n\n      var existingSortBy = sortBy.find(function (d) {\n        return d.id === columnID;\n      });\n      var existingIndex = sortBy.findIndex(function (d) {\n        return d.id === columnID;\n      });\n      var hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n      var newSortBy = []; // What should we do with this sort action?\n\n      var action;\n\n      if (!disableMultiSort && multi) {\n        if (existingSortBy) {\n          action = 'toggle';\n        } else {\n          action = 'add';\n        }\n      } else {\n        // Normal mode\n        if (existingIndex !== sortBy.length - 1) {\n          action = 'replace';\n        } else if (existingSortBy) {\n          action = 'toggle';\n        } else {\n          action = 'replace';\n        }\n      } // Handle toggle states that will remove the sortBy\n\n\n      if (action === 'toggle' && // Must be toggling\n      !disableSortRemove && // If disableSortRemove, disable in general\n      !hasDescDefined && ( // Must not be setting desc\n      multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove\n      existingSortBy && // Finally, detect if it should indeed be removed\n      existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n        action = 'remove';\n      }\n\n      if (action === 'replace') {\n        newSortBy = [{\n          id: columnID,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }];\n      } else if (action === 'add') {\n        newSortBy = [].concat(_toConsumableArray(sortBy), [{\n          id: columnID,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }]); // Take latest n columns\n\n        newSortBy.splice(0, newSortBy.length - maxMultiSortColCount);\n      } else if (action === 'toggle') {\n        // This flips (or sets) the\n        newSortBy = sortBy.map(function (d) {\n          if (d.id === columnID) {\n            return _objectSpread2({}, d, {\n              desc: hasDescDefined ? desc : !existingSortBy.desc\n            });\n          }\n\n          return d;\n        });\n      } else if (action === 'remove') {\n        newSortBy = sortBy.filter(function (d) {\n          return d.id !== columnID;\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        sortBy: newSortBy\n      });\n    }, actions.sortByChange);\n  }; // Add the getSortByToggleProps method to columns and headers\n\n\n  flatHeaders.forEach(function (column) {\n    var accessor = column.accessor,\n        columnDisableSorting = column.disableSorting,\n        id = column.id;\n    var canSort = accessor ? getFirstDefined(columnDisableSorting === true ? false : undefined, disableSorting === true ? false : undefined, true) : false;\n    column.canSort = canSort;\n\n    if (column.canSort) {\n      column.toggleSortBy = function (desc, multi) {\n        return toggleSortBy(column.id, desc, multi);\n      };\n\n      column.clearSorting = function () {\n        return setState(function (old) {\n          var sortBy = old.sortBy;\n          var newSortBy = sortBy.filter(function (d) {\n            return d.id !== column.id;\n          });\n          return _objectSpread2({}, old, {\n            sortBy: newSortBy\n          });\n        }, actions.sortByChange);\n      };\n    }\n\n    column.getSortByToggleProps = function (props) {\n      return mergeProps({\n        onClick: canSort ? function (e) {\n          e.persist();\n          column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n        } : undefined,\n        style: {\n          cursor: canSort ? 'pointer' : undefined\n        },\n        title: 'Toggle SortBy'\n      }, applyPropHooks(instance.hooks.getSortByToggleProps, column, instance), props);\n    };\n\n    var columnSort = sortBy.find(function (d) {\n      return d.id === id;\n    });\n    column.isSorted = !!columnSort;\n    column.sortedIndex = sortBy.findIndex(function (d) {\n      return d.id === id;\n    });\n    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n  });\n  var sortedRows = React.useMemo(function () {\n    if (manualSorting || !sortBy.length) {\n      return rows;\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug) console.time('getSortedRows'); // Filter out sortBys that correspond to non existing columns\n\n    var availableSortBy = sortBy.filter(function (sort) {\n      return flatColumns.find(function (col) {\n        return col.id === sort.id;\n      });\n    });\n\n    var sortData = function sortData(rows) {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {\n        // Support custom sorting methods for each column\n        var column = flatColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (!column) {\n          throw new Error(\"React-Table: Could not find a column with id: \".concat(sort.id, \" while sorting\"));\n        }\n\n        var sortType = column.sortType; // Look up sortBy functions in this order:\n        // column function\n        // column string lookup on user sortType\n        // column string lookup on built-in sortType\n        // default function\n        // default string lookup on user sortType\n        // default string lookup on built-in sortType\n\n        var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n\n        if (!sortMethod) {\n          throw new Error(\"React-Table: Could not find a valid sortType of '\".concat(sortType, \"' for column '\").concat(sort.id, \"'.\"));\n        } // Return the correct sortFn.\n        // This function should always return in ascending order\n\n\n        return function (a, b) {\n          return sortMethod(a, b, sort.id);\n        };\n      }), // Map the directions\n      availableSortBy.map(function (sort) {\n        // Detect and use the sortInverted option\n        var column = flatColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (column && column.sortInverted) {\n          return sort.desc;\n        }\n\n        return !sort.desc;\n      })); // If there are sub-rows, sort them\n\n      sortedData.forEach(function (row) {\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('getSortedRows');\n    return sortData(rows);\n  }, [manualSorting, sortBy, debug, rows, flatColumns, orderByFn, userSortTypes]);\n  return _objectSpread2({}, instance, {\n    toggleSortBy: toggleSortBy,\n    rows: sortedRows,\n    preSortedRows: rows\n  });\n}\n\ndefaultState.pageSize = 10;\ndefaultState.pageIndex = 0;\naddActions('pageChange', 'pageSizeChange');\nvar propTypes$5 = {\n  // General\n  manualPagination: PropTypes.bool,\n  paginateExpandedRows: PropTypes.bool\n};\n\nvar usePagination = function usePagination(hooks) {\n  hooks.useMain.push(useMain$4);\n};\n\nusePagination.pluginName = 'usePagination';\n\nfunction useMain$4(instance) {\n  PropTypes.checkPropTypes(propTypes$5, instance, 'property', 'usePagination');\n  var data = instance.data,\n      rows = instance.rows,\n      manualPagination = instance.manualPagination,\n      disablePageResetOnDataChange = instance.disablePageResetOnDataChange,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      debug = instance.debug,\n      plugins = instance.plugins,\n      userPageCount = instance.pageCount,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      _instance$state = instance.state,\n      pageSize = _instance$state.pageSize,\n      pageIndex = _instance$state.pageIndex,\n      filters = _instance$state.filters,\n      groupBy = _instance$state.groupBy,\n      sortBy = _instance$state.sortBy,\n      expanded = _instance$state.expanded,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination', []);\n  var rowDep = manualPagination ? null : data;\n  var isPageIndexMountedRef = React.useRef(); // Bypass any effects from firing when this changes\n\n  var disablePageResetOnDataChangeRef = React.useRef();\n  disablePageResetOnDataChangeRef.current = disablePageResetOnDataChange;\n  safeUseLayoutEffect(function () {\n    if (isPageIndexMountedRef.current && !disablePageResetOnDataChangeRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          pageIndex: 0\n        });\n      }, actions.pageChange);\n    }\n\n    isPageIndexMountedRef.current = true;\n  }, [setState, rowDep, filters, groupBy, sortBy]);\n  var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n  var pageOptions = React.useMemo(function () {\n    return pageCount > 0 ? _toConsumableArray(new Array(pageCount)).map(function (d, i) {\n      return i;\n    }) : [];\n  }, [pageCount]);\n  var page = React.useMemo(function () {\n    var page;\n\n    if (manualPagination) {\n      page = rows;\n    } else {\n      if (process.env.NODE_ENV === 'development' && debug) console.info('getPage');\n      var pageStart = pageSize * pageIndex;\n      var pageEnd = pageStart + pageSize;\n      page = rows.slice(pageStart, pageEnd);\n    }\n\n    if (paginateExpandedRows) {\n      return page;\n    }\n\n    return expandRows(page, {\n      manualExpandedKey: manualExpandedKey,\n      expanded: expanded,\n      expandSubRows: expandSubRows\n    });\n  }, [debug, expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);\n  var canPreviousPage = pageIndex > 0;\n  var canNextPage = pageCount === -1 || pageIndex < pageCount - 1;\n  var gotoPage = React.useCallback(function (updater) {\n    if (process.env.NODE_ENV === 'development' && debug) console.info('gotoPage');\n    return setState(function (old) {\n      var newPageIndex = typeof updater === 'function' ? updater(old.pageIndex) : updater;\n\n      if (newPageIndex < 0 || newPageIndex > pageCount - 1) {\n        return old;\n      }\n\n      return _objectSpread2({}, old, {\n        pageIndex: newPageIndex\n      });\n    }, actions.pageChange);\n  }, [debug, pageCount, setState]);\n  var previousPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old - 1;\n    });\n  }, [gotoPage]);\n  var nextPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old + 1;\n    });\n  }, [gotoPage]);\n  var setPageSize = React.useCallback(function (pageSize) {\n    setState(function (old) {\n      var topRowIndex = old.pageSize * old.pageIndex;\n      var pageIndex = Math.floor(topRowIndex / pageSize);\n      return _objectSpread2({}, old, {\n        pageIndex: pageIndex,\n        pageSize: pageSize\n      });\n    }, actions.pageSizeChange);\n  }, [setState]);\n  return _objectSpread2({}, instance, {\n    pageOptions: pageOptions,\n    pageCount: pageCount,\n    page: page,\n    canPreviousPage: canPreviousPage,\n    canNextPage: canNextPage,\n    gotoPage: gotoPage,\n    previousPage: previousPage,\n    nextPage: nextPage,\n    setPageSize: setPageSize,\n    pageIndex: pageIndex,\n    pageSize: pageSize\n  });\n}\n\ndefaultState.selectedRowPaths = [];\naddActions('toggleRowSelected', 'toggleRowSelectedAll');\nvar propTypes$6 = {\n  manualRowSelectedKey: PropTypes.string\n};\n\nvar useRowSelect = function useRowSelect(hooks) {\n  hooks.getToggleRowSelectedProps = [];\n  hooks.getToggleAllRowsSelectedProps = [];\n  hooks.useRows.push(useRows);\n  hooks.useMain.push(useMain$5);\n};\n\nuseRowSelect.pluginName = 'useRowSelect';\n\nfunction useRows(rows, instance) {\n  PropTypes.checkPropTypes(propTypes$6, instance, 'property', 'useRowSelect');\n  var selectedRowPaths = instance.state.selectedRowPaths;\n  instance.selectedFlatRows = React.useMemo(function () {\n    var selectedFlatRows = [];\n    rows.forEach(function (row) {\n      if (row.isAggregated) {\n        var subRowPaths = row.subRows.map(function (row) {\n          return row.path;\n        });\n        row.isSelected = subRowPaths.every(function (path) {\n          return selectedRowPaths.includes(path.join('.'));\n        });\n      } else {\n        row.isSelected = selectedRowPaths.includes(row.path.join('.'));\n      }\n\n      if (row.isSelected) {\n        selectedFlatRows.push(row);\n      }\n    });\n    return selectedFlatRows;\n  }, [rows, selectedRowPaths]);\n  return rows;\n}\n\nfunction useMain$5(instance) {\n  PropTypes.checkPropTypes(propTypes$6, instance, 'property', 'useRowSelect');\n  var hooks = instance.hooks,\n      _instance$manualRowSe = instance.manualRowSelectedKey,\n      manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe,\n      disableSelectedRowsResetOnDataChange = instance.disableSelectedRowsResetOnDataChange,\n      plugins = instance.plugins,\n      flatRows = instance.flatRows,\n      data = instance.data,\n      selectedRowPaths = instance.state.selectedRowPaths,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy'], 'useRowSelect', []);\n  var flatRowPaths = flatRows.map(function (d) {\n    return d.path.join('.');\n  });\n  var isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.length;\n\n  if (isAllRowsSelected) {\n    if (flatRowPaths.some(function (d) {\n      return !selectedRowPaths.includes(d);\n    })) {\n      isAllRowsSelected = false;\n    }\n  }\n\n  var isRowSelectedMountedRef = React.useRef(); // Bypass any effects from firing when this changes\n\n  var disableSelectedRowsResetOnDataChangeRef = React.useRef();\n  disableSelectedRowsResetOnDataChangeRef.current = disableSelectedRowsResetOnDataChange;\n  safeUseLayoutEffect(function () {\n    if (isRowSelectedMountedRef.current && !disableSelectedRowsResetOnDataChangeRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          selectedRowPaths: []\n        });\n      }, actions.pageChange);\n    }\n\n    isRowSelectedMountedRef.current = true;\n  }, [setState, data]);\n\n  var toggleRowSelectedAll = function toggleRowSelectedAll(set) {\n    setState(function (old) {\n      var selectAll = typeof set !== 'undefined' ? set : !isAllRowsSelected;\n      return _objectSpread2({}, old, {\n        selectedRowPaths: selectAll ? flatRowPaths : []\n      });\n    }, actions.toggleRowSelectedAll);\n  };\n\n  var updateParentRow = function updateParentRow(selectedRowPaths, path) {\n    var parentPath = path.slice(0, path.length - 1);\n    var parentKey = parentPath.join('.');\n    var selected = flatRowPaths.filter(function (rowPath) {\n      var path = rowPath;\n      return path !== parentKey && path.startsWith(parentKey) && !selectedRowPaths.has(path);\n    }).length === 0;\n\n    if (selected) {\n      selectedRowPaths.add(parentKey);\n    } else {\n      selectedRowPaths.delete(parentKey);\n    }\n\n    if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath);\n  };\n\n  var toggleRowSelected = function toggleRowSelected(path, set) {\n    var key = path.join('.');\n    var childRowPrefixKey = [key, '.'].join('');\n    return setState(function (old) {\n      // Join the paths of deep rows\n      // to make a key, then manage all of the keys\n      // in a flat object\n      var exists = old.selectedRowPaths.includes(key);\n      var shouldExist = typeof set !== 'undefined' ? set : !exists;\n      var newSelectedRows = new Set(old.selectedRowPaths);\n\n      if (!exists && shouldExist) {\n        flatRowPaths.forEach(function (rowPath) {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.add(rowPath);\n          }\n        });\n      } else if (exists && !shouldExist) {\n        flatRowPaths.forEach(function (rowPath) {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.delete(rowPath);\n          }\n        });\n      } else {\n        return old;\n      } // If the row is a subRow update\n      // its parent row to reflect changes\n\n\n      if (path.length > 1) updateParentRow(newSelectedRows, path);\n      return _objectSpread2({}, old, {\n        selectedRowPaths: _toConsumableArray(newSelectedRows.values())\n      });\n    }, actions.toggleRowSelected);\n  };\n\n  var getToggleAllRowsSelectedProps = function getToggleAllRowsSelectedProps(props) {\n    return mergeProps({\n      onChange: function onChange(e) {\n        toggleRowSelectedAll(e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: isAllRowsSelected,\n      title: 'Toggle All Rows Selected'\n    }, applyPropHooks(instance.hooks.getToggleAllRowsSelectedProps, instance), props);\n  };\n\n  hooks.prepareRow.push(function (row) {\n    // Aggregate rows have entirely different select logic\n    if (row.isAggregated) {\n      var subRowPaths = row.subRows.map(function (row) {\n        return row.path;\n      });\n\n      row.toggleRowSelected = function (set) {\n        set = typeof set !== 'undefined' ? set : !row.isSelected;\n        subRowPaths.forEach(function (path) {\n          toggleRowSelected(path, set);\n        });\n      };\n\n      row.getToggleRowSelectedProps = function (props) {\n        var checked = false;\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true;\n        } else {\n          checked = row.isSelected;\n        }\n\n        return mergeProps({\n          onChange: function onChange(e) {\n            row.toggleRowSelected(e.target.checked);\n          },\n          style: {\n            cursor: 'pointer'\n          },\n          checked: checked,\n          title: 'Toggle Row Selected'\n        }, applyPropHooks(instance.hooks.getToggleRowSelectedProps, row, instance), props);\n      };\n    } else {\n      row.toggleRowSelected = function (set) {\n        return toggleRowSelected(row.path, set);\n      };\n\n      row.getToggleRowSelectedProps = function (props) {\n        var checked = false;\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true;\n        } else {\n          checked = row.isSelected;\n        }\n\n        return mergeProps({\n          onChange: function onChange(e) {\n            row.toggleRowSelected(e.target.checked);\n          },\n          style: {\n            cursor: 'pointer'\n          },\n          checked: checked,\n          title: 'Toggle Row Selected'\n        }, applyPropHooks(instance.hooks.getToggleRowSelectedProps, row, instance), props);\n      };\n    }\n\n    return row;\n  });\n  return _objectSpread2({}, instance, {\n    toggleRowSelected: toggleRowSelected,\n    toggleRowSelectedAll: toggleRowSelectedAll,\n    getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,\n    isAllRowsSelected: isAllRowsSelected\n  });\n}\n\ndefaultState.rowState = {};\naddActions('setRowState', 'setCellState');\nvar propTypes$7 = {\n  initialRowStateAccessor: PropTypes.func\n};\n\nvar useRowState = function useRowState(hooks) {\n  hooks.useMain.push(useMain$6);\n};\n\nuseRowState.pluginName = 'useRowState';\n\nfunction useMain$6(instance) {\n  PropTypes.checkPropTypes(propTypes$7, instance, 'property', 'useRowState');\n  var hooks = instance.hooks,\n      rows = instance.rows,\n      initialRowStateAccessor = instance.initialRowStateAccessor,\n      rowState = instance.state.rowState,\n      setState = instance.setState;\n  var setRowState = React.useCallback(function (path, updater) {\n    var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : actions.setRowState;\n    var pathKey = path.join('.');\n    return setState(function (old) {\n      return _objectSpread2({}, old, {\n        rowState: _objectSpread2({}, old.rowState, _defineProperty({}, pathKey, typeof updater === 'function' ? updater(old.rowState[pathKey]) : updater))\n      });\n    }, action);\n  }, [setState]);\n  var setCellState = React.useCallback(function (rowPath, columnID, updater) {\n    return setRowState(rowPath, function (old) {\n      return _objectSpread2({}, old, {\n        cellState: _objectSpread2({}, old.cellState, _defineProperty({}, columnID, typeof updater === 'function' ? updater(old.cellState[columnID]) : updater))\n      });\n    }, actions.setCellState);\n  }, [setRowState]);\n  var rowsMountedRef = React.useRef(); // When data changes, reset row and cell state\n\n  React.useEffect(function () {\n    if (rowsMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          rowState: {}\n        });\n      }, actions.setRowState);\n    }\n\n    rowsMountedRef.current = true;\n  }, [rows, setState]);\n  hooks.prepareRow.push(function (row) {\n    var pathKey = row.path.join('.');\n\n    if (row.original) {\n      row.state = (typeof rowState[pathKey] !== 'undefined' ? rowState[pathKey] : initialRowStateAccessor && initialRowStateAccessor(row)) || {};\n\n      row.setState = function (updater) {\n        return setRowState(row.path, updater);\n      };\n\n      row.cells.forEach(function (cell) {\n        cell.state = row.state.cellState || {};\n\n        cell.setState = function (updater) {\n          return setCellState(row.path, cell.column.id, updater);\n        };\n      });\n    }\n\n    return row;\n  });\n  return _objectSpread2({}, instance, {\n    setRowState: setRowState,\n    setCellState: setCellState\n  });\n}\n\ndefaultState.columnOrder = [];\naddActions('setColumnOrder');\nvar propTypes$8 = {\n  initialRowStateAccessor: PropTypes.func\n};\n\nvar useColumnOrder = function useColumnOrder(hooks) {\n  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {\n    return [].concat(_toConsumableArray(deps), [instance.state.columnOrder]);\n  });\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups$1);\n  hooks.useMain.push(useMain$7);\n};\n\nuseColumnOrder.pluginName = 'useColumnOrder';\n\nfunction columnsBeforeHeaderGroups$1(columns, instance) {\n  var columnOrder = instance.state.columnOrder; // If there is no order, return the normal columns\n\n  if (!columnOrder || !columnOrder.length) {\n    return columns;\n  }\n\n  var columnOrderCopy = _toConsumableArray(columnOrder); // If there is an order, make a copy of the columns\n\n\n  var columnsCopy = _toConsumableArray(columns); // And make a new ordered array of the columns\n\n\n  var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n\n  var _loop = function _loop() {\n    var targetColumnID = columnOrderCopy.shift();\n    var foundIndex = columnsCopy.findIndex(function (d) {\n      return d.id === targetColumnID;\n    });\n\n    if (foundIndex > -1) {\n      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n    }\n  };\n\n  while (columnsCopy.length && columnOrderCopy.length) {\n    _loop();\n  } // If there are any columns left, add them to the end\n\n\n  return [].concat(columnsInOrder, _toConsumableArray(columnsCopy));\n}\n\nfunction useMain$7(instance) {\n  PropTypes.checkPropTypes(propTypes$8, instance, 'property', 'useColumnOrder');\n  var setState = instance.setState;\n  var setColumnOrder = React.useCallback(function (updater) {\n    return setState(function (old) {\n      return _objectSpread2({}, old, {\n        columnOrder: typeof updater === 'function' ? updater(old.columnOrder) : updater\n      });\n    }, actions.setColumnOrder);\n  }, [setState]);\n  return _objectSpread2({}, instance, {\n    setColumnOrder: setColumnOrder\n  });\n}\n\ndefaultState.columnResizing = {\n  columnWidths: {}\n};\ndefaultColumn.canResize = true;\nvar propTypes$9 = {};\n\nvar useResizeColumns = function useResizeColumns(hooks) {\n  hooks.useBeforeDimensions.push(useBeforeDimensions);\n};\n\nuseResizeColumns.pluginName = 'useResizeColumns';\n\nvar useBeforeDimensions = function useBeforeDimensions(instance) {\n  PropTypes.checkPropTypes(propTypes$9, instance, 'property', 'useResizeColumns');\n  instance.hooks.getResizerProps = [];\n  var flatHeaders = instance.flatHeaders,\n      disableResizing = instance.disableResizing,\n      getHeaderProps = instance.hooks.getHeaderProps,\n      columnResizing = instance.state.columnResizing,\n      setState = instance.setState;\n  getHeaderProps.push(function () {\n    return {\n      style: {\n        position: 'relative'\n      }\n    };\n  });\n\n  var _onMouseDown = function onMouseDown(e, header) {\n    var headersToResize = getLeafHeaders(header);\n    var startWidths = headersToResize.map(function (header) {\n      return header.totalWidth;\n    });\n    var startX = e.clientX;\n\n    var onMouseMove = function onMouseMove(e) {\n      var currentX = e.clientX;\n      var deltaX = currentX - startX;\n      var percentageDeltaX = deltaX / headersToResize.length;\n      var newColumnWidths = {};\n      headersToResize.forEach(function (header, index) {\n        newColumnWidths[header.id] = Math.max(startWidths[index] + percentageDeltaX, 0);\n      });\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          columnResizing: _objectSpread2({}, old.columnResizing, {\n            columnWidths: _objectSpread2({}, old.columnResizing.columnWidths, {}, newColumnWidths)\n          })\n        });\n      });\n    };\n\n    var onMouseUp = function onMouseUp(e) {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          columnResizing: _objectSpread2({}, old.columnResizing, {\n            startX: null,\n            isResizingColumn: null\n          })\n        });\n      });\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    setState(function (old) {\n      return _objectSpread2({}, old, {\n        columnResizing: _objectSpread2({}, old.columnResizing, {\n          startX: startX,\n          isResizingColumn: header.id\n        })\n      });\n    });\n  };\n\n  flatHeaders.forEach(function (header) {\n    var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n    header.canResize = canResize;\n    header.width = columnResizing.columnWidths[header.id] || header.width;\n    header.isResizing = columnResizing.isResizingColumn === header.id;\n\n    if (canResize) {\n      header.getResizerProps = function (userProps) {\n        return mergeProps({\n          onMouseDown: function onMouseDown(e) {\n            return e.persist() || _onMouseDown(e, header);\n          },\n          style: {\n            cursor: 'ew-resize'\n          },\n          draggable: false\n        }, applyPropHooks(instance.hooks.getResizerProps, header, instance), userProps);\n      };\n    }\n  });\n  return instance;\n};\n\nfunction getLeafHeaders(header) {\n  var leafHeaders = [];\n\n  var recurseHeader = function recurseHeader(header) {\n    if (header.columns && header.columns.length) {\n      header.columns.map(recurseHeader);\n    }\n\n    leafHeaders.push(header);\n  };\n\n  recurseHeader(header);\n  return leafHeaders;\n}\n\nvar propTypes$a = {};\n\nvar useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n  hooks.useMain.push(useMain$8);\n};\n\nuseAbsoluteLayout.pluginName = 'useAbsoluteLayout';\n\nvar useMain$8 = function useMain(instance) {\n  PropTypes.checkPropTypes(propTypes$a, instance, 'property', 'useAbsoluteLayout');\n  var totalColumnsWidth = instance.totalColumnsWidth,\n      _instance$hooks = instance.hooks,\n      getRowProps = _instance$hooks.getRowProps,\n      getTableBodyProps = _instance$hooks.getTableBodyProps,\n      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,\n      getHeaderProps = _instance$hooks.getHeaderProps,\n      getCellProps = _instance$hooks.getCellProps;\n  var rowStyles = {\n    style: {\n      position: 'relative',\n      width: \"\".concat(totalColumnsWidth, \"px\")\n    }\n  };\n  getTableBodyProps.push(function () {\n    return rowStyles;\n  });\n  getRowProps.push(function () {\n    return rowStyles;\n  });\n  getHeaderGroupProps.push(function () {\n    return rowStyles;\n  }); // Calculating column/cells widths\n\n  var cellStyles = {\n    position: 'absolute',\n    top: 0\n  };\n  getHeaderProps.push(function (header) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        left: \"\".concat(header.totalLeft, \"px\"),\n        width: \"\".concat(header.totalWidth, \"px\")\n      })\n    };\n  });\n  getCellProps.push(function (cell) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        left: \"\".concat(cell.column.totalLeft, \"px\"),\n        width: \"\".concat(cell.column.totalWidth, \"px\")\n      })\n    };\n  });\n  return instance;\n};\n\nvar propTypes$b = {};\n\nvar useBlockLayout = function useBlockLayout(hooks) {\n  hooks.useMain.push(useMain$9);\n};\n\nuseBlockLayout.pluginName = 'useBlockLayout';\n\nvar useMain$9 = function useMain(instance) {\n  PropTypes.checkPropTypes(propTypes$b, instance, 'property', 'useBlockLayout');\n  var totalColumnsWidth = instance.totalColumnsWidth,\n      _instance$hooks = instance.hooks,\n      getRowProps = _instance$hooks.getRowProps,\n      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,\n      getHeaderProps = _instance$hooks.getHeaderProps,\n      getCellProps = _instance$hooks.getCellProps;\n  var rowStyles = {\n    style: {\n      display: 'flex',\n      width: \"\".concat(totalColumnsWidth, \"px\")\n    }\n  };\n  getRowProps.push(function () {\n    return rowStyles;\n  });\n  getHeaderGroupProps.push(function () {\n    return rowStyles;\n  });\n  var cellStyles = {\n    display: 'inline-block',\n    boxSizing: 'border-box'\n  };\n  getHeaderProps.push(function (header) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        width: \"\".concat(header.totalWidth, \"px\")\n      })\n    };\n  });\n  getCellProps.push(function (cell) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        width: \"\".concat(cell.column.totalWidth, \"px\")\n      })\n    };\n  });\n  return instance;\n};\n\nexport { utils, defaultColumn, useTable, defaultState, useExpanded, useFilters, useGroupBy, useSortBy, usePagination, useRowSelect, useRowState, useColumnOrder, useResizeColumns, useAbsoluteLayout, useBlockLayout, actions, addActions };"],"sourceRoot":""}